# INGENIERIA INVERSA COMPLETA: NEOBOOKINGS DATABASE
**Sistema de Gestión Hotelera - Channel Manager & Booking Engine**

**Fecha de Análisis:** 2025-11-04
**Base de Datos:** neobookings_latest
**Total de Tablas:** 249
**Tamaño Total:** 71.57 GB (58.52 GB datos + 13.05 GB índices)
**Filas Totales (estimadas):** 155,612,366
**Motor de Almacenamiento:** InnoDB (100%)

---

## RESUMEN EJECUTIVO

### Hallazgos Críticos

**ANTI-PATTERN #1: AUSENCIA TOTAL DE FOREIGN KEYS**
- **Impacto:** CRÍTICO
- **Evidencia:** 0 (cero) foreign keys explícitas en toda la base de datos
- **Consecuencia:** Integridad referencial gestionada 100% a nivel aplicación
- **Riesgo:** Datos huérfanos, inconsistencias, imposibilidad de cascadas automáticas
- **Recomendación:** Implementar FKs progresivamente en tablas críticas (nb_reservas, nb_hoteles, nb_habitaciones)

**ANTI-PATTERN #2: COLUMNA `identificador` COMO PRIMARY KEY (VARCHAR)**
- **Impacto:** ALTO
- **Evidencia:** Tabla `nb_reservas` usa VARCHAR(13) como PK en lugar de INT/BIGINT AUTO_INCREMENT
- **Consecuencia:**
  - Mayor consumo de espacio en índices (13 bytes vs 4/8 bytes)
  - Penalización en JOINs (comparación de strings vs enteros)
  - Fragmentación del InnoDB clustered index
- **Tablas afectadas:** nb_reservas (6.9M filas), nb_reservas_canales (2.8M filas), nb_reservas_desgloses (5.3M filas)
- **Coste estimado:** 30-40% overhead en queries de JOIN con reservas

**ANTI-PATTERN #3: SOFT DELETES INCONSISTENTES**
- **Impacto:** MEDIO
- **Evidencia:** Algunas tablas usan `eliminada` (ENUM), otras `eliminado` (TINYINT), otras `activa`/`visible`
- **Inconsistencia:** No hay patrón unificado para soft deletes
- **Recomendación:** Estandarizar con columna `deleted_at TIMESTAMP NULL` (patrón Laravel/moderna)

**ANTI-PATTERN #4: COLUMNAS JSON SIN ÍNDICES VIRTUALES**
- **Impacto:** MEDIO
- **Evidencia:** Columnas `datos`, `disfrute_productos`, `neopayments_data` (tipo JSON) sin índices generados
- **Consecuencia:** Queries sobre campos JSON requieren full table scans
- **Ejemplo:** nb_reservas.datos (6.9M filas), nb_pagos.neopayments_data (1.4M filas)

**PATRÓN POSITIVO: TIMESTAMPS DE AUDITORÍA**
- 95% de las tablas tienen columna `last_update` (TIMESTAMP) con ON UPDATE CURRENT_TIMESTAMP
- Permite tracking de cambios básico
- Falta: `created_at` en muchas tablas (solo tienen `timestamp` o `fecha_creacion`)

---

## ARQUITECTURA LÓGICA

### Clasificación de Dominios (249 tablas)

#### **1. RESERVAS (18 tablas)** - 47.6 GB (66% del total)
Núcleo transaccional del sistema. Gestiona el ciclo completo de reservas desde creación hasta facturación.

**Tablas principales:**
- `nb_reservas` (6.9M filas, 8.6 GB) - **Entidad principal de reserva**
- `nb_reservas_desgloses` (5.3M filas, 22.0 GB) - **Desglose de precios por noche/concepto**
- `nb_reservas_canales` (2.8M filas, 8.9 GB) - Reservas desde Channel Manager/OTAs
- `nb_reservas_habitaciones` (6.4M filas, 1.4 GB) - **Líneas de habitación por reserva (M:N con nb_habitaciones)**
- `nb_reservas_politicas` (6.9M filas, 5.0 GB) - Políticas de cancelación aplicadas
- `nb_reservas_ocupantes` (5.1M filas, 536 MB) - Datos de ocupantes (PAX)
- `nb_reservas_tracking` (1.7M filas, 661 MB) - Estados del workflow (confirmado, realizado, cancelado)
- `nb_reservas_canales_habitaciones` (3.3M filas, 324 MB)
- `nb_reservas_acciones` (1.2M filas, 342 MB)
- `nb_reservas_paquetes` (166K filas, 23 MB)
- `nb_reservas_suplementos` (76K filas, 6 MB)
- `nb_reservas_facturacion` (43K filas, 5.5 MB)
- `nb_reservas_bonos_regalo` (20K filas, 4 MB)
- `nb_reservas_pms` (195K filas, 17 MB) - Integración con PMS externo
- `nb_reservas_profesionales` (12K filas, 2 MB)
- `nb_reservas_productos`, `nb_reservas_traslados`, `nb_reservas_facebook`, etc.

**Tablas relacionadas (nuevo sistema):**
- `reservation_notification` (1.5M filas, 688 MB)
- `reservation_event` (1.4M filas, 99 MB)
- `reservation_external_system` (22K filas, 39 MB)

**Relaciones implícitas clave:**
- `nb_reservas.identificador` (PK) → `nb_reservas_habitaciones.identificador` (FK implícita)
- `nb_reservas_habitaciones.id_hotel_rh` → `nb_hoteles.id_hotel`
- `nb_reservas_habitaciones.id_habitacion` → `nb_habitaciones.id_habitacion`
- `nb_reservas.pais` → `nb_paises` (código ISO 2 letras)
- `nb_reservas.moneda` → `nb_currencies` (código ISO 3 letras)
- `nb_reservas.idioma` → `nb_languages` (código ISO 2 letras)

**Estados (workflow):**
```sql
nb_reservas.estado: ENUM('confirmada', 'cancelada', 'nula') DEFAULT 'confirmada'
nb_reservas.revisada: ENUM('si', 'no') DEFAULT 'no'
nb_reservas.no_show: TINYINT DEFAULT 0
nb_reservas.autorizacion: ENUM('si', 'no') NULL
```

**Patrón de precios:**
- Precio total calculado: `nb_reservas.precio_total` (DECIMAL)
- Esquema de pago fraccionado: `nb_reservas.primer_pago`, `nb_reservas.segundo_pago`
- Desglose detallado en: `nb_reservas_desgloses` (1 fila por noche/concepto)

---

#### **2. HOTELES (8 tablas)** - 157 MB
Catálogo de propiedades hoteleras. Soporte multi-idioma mediante tabla `.lang`.

**Tablas principales:**
- `nb_hoteles` (1,610 filas, 1.56 MB) - **Entidad hotel**
- `nb_hoteles.lang` (19,580 filas, 143 MB) - **Traducciones masivas de descripciones/políticas**
- `nb_hoteles_usuario` (19,877 filas, 3.5 MB) - **M:N usuarios-hoteles (permisos)**
- `nb_hoteles_ofertas_cadena` (145,650 filas, 9 MB)
- `nb_hoteles_grupo` (1,433 filas, 0.2 MB)
- `nb_hoteles_idiomas` (5,875 filas, 0.19 MB)
- `nb_hoteles_facturacion` (1,299 filas, 0.3 MB)
- `nb_hoteles_profesional` (632 filas, 0.05 MB)

**Estructura de nb_hoteles (45 columnas):**
```sql
CREATE TABLE nb_hoteles (
  id_hotel INT AUTO_INCREMENT PRIMARY KEY,
  hash VARCHAR(255) NOT NULL,
  nombre_hotel VARCHAR(255) NOT NULL,
  categoria CHAR(5) NULL,
  id_cadena INT NULL,  -- FK implícita a nb_cadenas
  direccion VARCHAR(255),
  pais CHAR(2) NOT NULL DEFAULT 'ES',
  zona VARCHAR(4),
  zona_horaria VARCHAR(255) NOT NULL DEFAULT 'Europe/Madrid',
  telefono VARCHAR(50),
  web VARCHAR(255),
  idioma VARCHAR(2) DEFAULT 'es',
  moneda CHAR(3) NOT NULL DEFAULT 'EUR',
  num_habitaciones SMALLINT,
  email VARCHAR(255),
  apertura_hotel DATE,
  cierre_hotel DATE,
  reapertura_hotel DATE,
  latitud DECIMAL(9,6) NOT NULL DEFAULT 0,
  longitud DECIMAL(9,6) NOT NULL DEFAULT 0,
  impuesto DECIMAL(4,2) NOT NULL DEFAULT 7.00,
  pago_hotel ENUM('si','no') NOT NULL DEFAULT 'no',
  acepta_bebes ENUM('si','no') NOT NULL DEFAULT 'si',
  edad_bebes SMALLINT NOT NULL DEFAULT 1,
  acepta_ninos ENUM('si','no') NOT NULL DEFAULT 'si',
  edad_ninos SMALLINT NOT NULL DEFAULT 12,
  activo ENUM('si','no') NOT NULL DEFAULT 'no',  -- Soft delete pattern
  last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  -- ... (20+ columnas adicionales)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;

INDEX id_cadena (id_cadena)
```

**Patrón i18n (nb_hoteles.lang):**
```sql
CREATE TABLE `nb_hoteles.lang` (
  id_hotel INT NOT NULL,
  language CHAR(2) NOT NULL,
  descripcion_hotel TEXT,
  condiciones_reserva TEXT,
  politica_cancelacion TEXT,
  politica_privacidad TEXT,
  ... (15+ columnas de texto traducibles),
  PRIMARY KEY (id_hotel, language)
) ENGINE=InnoDB;
```
**Observación:** Sin FK a nb_hoteles ni nb_languages. Integridad en código.

**Relaciones implícitas:**
- `nb_hoteles.id_cadena` → `nb_cadenas.id_cadena` (relación hotel-cadena)
- `nb_hoteles.pais` → `nb_paises` (ISO 2 letras)
- `nb_hoteles.zona` → `nb_zonas` (código de zona geográfica)
- `nb_hoteles_usuario.login` → `nb_usuarios.login` (permisos de usuario a hotel)

---

#### **3. HABITACIONES (6 tablas)** - 43 MB
Inventario de tipos de habitación. Sistema de variantes (id_principal) y capacidades complejas.

**Tablas:**
- `nb_habitaciones` (17,899 filas, 3.7 MB)
- `nb_habitaciones.lang` (184,527 filas, 34.6 MB) - Traducciones
- `nb_habitaciones_ambientes` (2,278 filas, 0.11 MB) - M:N con ambientes
- `nb_habitaciones_ambientes.lang` (34,399 filas, 2.5 MB)
- `nb_habitaciones_textos` (157 filas, 0.02 MB)
- `nb_habitaciones_textos.lang` (2,565 filas, 2.5 MB)

**Estructura de nb_habitaciones (26 columnas):**
```sql
CREATE TABLE nb_habitaciones (
  id_habitacion INT AUTO_INCREMENT PRIMARY KEY,
  id_hotel INT NOT NULL,  -- FK implícita
  id_principal INT NULL,  -- Patrón de VARIANTES (room type vs room variant)
  cantidad MEDIUMINT NOT NULL DEFAULT 0,  -- Unidades físicas disponibles
  id_global VARCHAR(255) NOT NULL,  -- Identificador único global (posiblemente para channel mapping)
  modos_reserva SET('habitaciones','paquetes','productos') NOT NULL DEFAULT 'habitaciones,paquetes,productos',
  agrupacion SMALLINT NULL,
  clase_upgrade SMALLINT NOT NULL DEFAULT 1,
  permitir_upgrade ENUM('always','never') NOT NULL DEFAULT 'always',
  capacidad SMALLINT NOT NULL DEFAULT 0,
  capacidad_adultos SMALLINT NOT NULL DEFAULT 0,
  capacidad_ninos SMALLINT NOT NULL DEFAULT 0,
  capacidad_minima SMALLINT NOT NULL DEFAULT 0,
  tarificacion_minima SMALLINT NOT NULL DEFAULT 0,
  superficie DECIMAL(5,2) NOT NULL DEFAULT 0.00,
  facturacion ENUM('pax','alojamiento') NULL,
  equipamiento VARCHAR(2048),
  caracteristicas VARCHAR(1024),
  activa ENUM('si','no') NOT NULL DEFAULT 'si',  -- Soft delete #1
  visible ENUM('si','no') NOT NULL DEFAULT 'si',  -- Soft delete #2
  eliminada ENUM('si','no') NOT NULL DEFAULT 'no',  -- Soft delete #3 (!!!)
  orden SMALLINT NOT NULL DEFAULT 0,
  last_update TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;

INDEX id_hotel (id_hotel),
INDEX id_principal (id_principal),
INDEX activa (activa, eliminada),  -- Índice compuesto para soft deletes
INDEX orden (orden)
```

**ANTI-PATTERN DETECTADO:** Triple soft delete (`activa`, `visible`, `eliminada`). Lógica de negocio compleja:
- `activa='no'` → habitación desactivada temporalmente
- `visible='no'` → oculta en frontend pero puede estar activa en backend
- `eliminada='si'` → borrado lógico permanente

**Patrón de variantes (id_principal):**
- `id_principal IS NULL` → Habitación principal (master)
- `id_principal = X` → Variante de la habitación X (ej: "Doble" master, "Doble con terraza" variante)
- Permite definir precio/disponibilidad independiente pero hereda configuración base

**Relaciones implícitas:**
- `nb_habitaciones.id_hotel` → `nb_hoteles.id_hotel`
- `nb_habitaciones.id_principal` → `nb_habitaciones.id_habitacion` (self-join)
- `nb_habitaciones_ambientes.id_habitacion` → `nb_habitaciones.id_habitacion`
- `nb_habitaciones_ambientes.id_ambiente` → (tabla nb_ambientes no existe, posible catálogo externo o deprecado)

---

#### **4. CHANNELS/OTA (33 tablas)** - 10.7 GB (15% del total)
Subsistema de Channel Manager. Sincronización con OTAs (Booking.com, Expedia, etc.), gestión de inventario/precios en tiempo real.

**Tablas críticas:**
- `nb_mod_channels_inventory` (13.7M filas, 6.25 GB) - **Inventario por fecha/canal/habitación**
- `nb_mod_channels_bookings` (3.3M filas, 2.2 GB) - Reservas desde canales externos
- `nb_mod_channels_bookings_rooms` (4.4M filas, 1.1 GB)
- `nb_mod_channels_bookings_notifications` (6.7M filas, 465 MB) - Log de notificaciones push
- `nb_mod_channels_inventory_ghpa` (2.7M filas, 1.7 GB) - Inventario GHPA (posible OTA específica)
- `nb_mod_channels_inventory_neo` (1.9M filas, 365 MB)
- `nb_mod_channels_stopsales` (223K filas, 65 MB)
- `nb_mod_channels_mapping` (227K filas, 56 MB) - **Mapeo entre id_habitacion interno y IDs de canales**
- `nb_mod_channels_inventory_rooms_prices` (105K filas, 36 MB)
- `nb_mod_channels_room_rates` (109K filas, 17 MB)
- `nb_mod_channels_rates` (56K filas, 5.5 MB)
- `nb_mod_channels_booking_reporting` (58K filas, 2.5 MB)
- `nb_mod_channels_booking_reporting_attempts` (56K filas, 7.5 MB)
- `nb_mod_channels_requests` (8.7K filas, 1.5 MB)
- Tablas de configuración: `nb_mod_channels_clients`, `nb_mod_channels_methods`, `nb_mod_channels_neoconnect_*`, etc.

**Estructura de nb_mod_channels_inventory (tabla más grande del sistema):**
```sql
CREATE TABLE nb_mod_channels_inventory (
  arrival DATE NOT NULL,
  id_hotel INT NOT NULL,
  roomId INT NOT NULL,  -- FK implícita a nb_habitaciones.id_habitacion
  channel VARCHAR(50) NOT NULL,
  portal VARCHAR(50) NOT NULL,
  nights INT NOT NULL,
  quantity INT NOT NULL,  -- Disponibilidad (cupo)
  pending TINYINT NOT NULL DEFAULT 0,
  priority TINYINT NOT NULL DEFAULT 0,
  error TEXT,
  sendError INT NOT NULL DEFAULT 0,
  status VARCHAR(50),
  last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (arrival, id_hotel, roomId, channel, portal, nights),
  INDEX id_hotel (id_hotel, pending),
  INDEX id_hotel_2 (id_hotel, arrival),
  INDEX pending (pending, error, id_hotel, quantity),
  INDEX last_update (last_update),
  INDEX status (status),
  INDEX priority (priority, sendError),
  INDEX roomId (roomId)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**PRIMARY KEY COMPUESTA (6 columnas):**
- **Granularidad:** por fecha entrada, hotel, habitación, canal, portal, noches
- **Impacto:** PK de 6 columnas = índice clustered muy ancho → overhead en secondary indexes
- **Justificación:** Necesario para evitar duplicados en sincronización multi-canal
- **Problema potencial:** Fragmentación del clustered index si inserts no son secuenciales por PK

**Índices estratégicos:**
- `id_hotel_2 (id_hotel, arrival)` → Query típica: "dame inventario de hotel X desde fecha Y"
- `pending (pending, error, id_hotel, quantity)` → Cola de procesamiento de sincronización pendiente
- `last_update` → Detectar cambios recientes para re-sync
- `roomId` → Lookup inverso: "qué canales tienen esta habitación"

**Patrón de sincronización:**
1. Cambio en `nb_cupos` (inventario interno) → trigger/job marca `pending=1`
2. Worker procesa filas `pending=1`, envía a canal vía API
3. Si éxito: `pending=0`, `last_update=NOW()`
4. Si error: `pending=1`, `error=<mensaje>`, `sendError++`
5. Retry con backoff exponencial según `priority`

**Relaciones implícitas:**
- `nb_mod_channels_inventory.id_hotel` → `nb_hoteles.id_hotel`
- `nb_mod_channels_inventory.roomId` → `nb_habitaciones.id_habitacion`
- `nb_mod_channels_bookings.identificador` → `nb_reservas.identificador` (sincronización bidireccional)
- `nb_mod_channels_mapping` une IDs internos con IDs de OTAs

---

#### **5. PAGOS/TPV (16 tablas)** - 543 MB
Gestión de transacciones de pago, cargos, planes de pago.

**Tablas principales:**
- `nb_cargos` (2.3M filas, 266 MB) - **Cargos programados/ejecutados**
- `nb_pagos` (1.4M filas, 262 MB) - **Registro de pagos realizados**
- `tpv_transaction` (70K filas, 13.6 MB) - Transacciones TPV (pasarela externa)
- `nb_planespago` (1,917 filas, 0.27 MB)
- `nb_planespago.lang` (36,175 filas, 1.5 MB)
- `nb_planespago_*` (8 tablas) - Relaciones M:N con hoteles, habitaciones, ofertas, paquetes
- `nb_tpv`, `nb_tpv_transacciones` (vacías, posible deprecación)
- `tpv_tokens` (vacía)

**Estructura de nb_cargos:**
```sql
CREATE TABLE nb_cargos (
  id_cargo INT AUTO_INCREMENT PRIMARY KEY,
  identificador VARCHAR(13) NOT NULL,  -- FK implícita a nb_reservas.identificador
  fecha_creacion TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
  fecha_ejecucion TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
  importe DECIMAL(10,2) NOT NULL,
  tipo_operacion ENUM('preautorizacion','cobro','devolucion') NOT NULL,
  estado ENUM('informativo','hotel','online','pendiente','procesado','cancelado','error') NOT NULL,
  notificado TINYINT NOT NULL DEFAULT 0,
  notas VARCHAR(2048) NOT NULL DEFAULT '',
  INDEX identificador (identificador),
  INDEX estado (estado)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**Estados de cargos (workflow):**
- `informativo` → Solo referencial, no ejecutar
- `hotel` → Pago en hotel (no online)
- `online` → Pago online
- `pendiente` → Programado para ejecución
- `procesado` → Ejecutado exitosamente
- `cancelado` → Cancelado manualmente
- `error` → Error en ejecución (requiere retry o intervención)

**Estructura de nb_pagos:**
```sql
CREATE TABLE nb_pagos (
  id INT AUTO_INCREMENT PRIMARY KEY,
  timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  identificador VARCHAR(10) NOT NULL,  -- FK implícita a nb_reservas
  metodo ENUM('tpv','tpv-manual','transferencia','efectivo','credito','paypal','otb','financiado','otro') NOT NULL DEFAULT 'tpv',
  cantidad DECIMAL(10,2) NOT NULL,
  moneda CHAR(3) NOT NULL DEFAULT 'EUR',
  descripcion TEXT NOT NULL,
  neopayments_id VARCHAR(64) NULL,
  neopayments_data JSON NULL,  -- ANTI-PATTERN: JSON sin índices generados
  eliminado TINYINT NOT NULL DEFAULT 0,  -- Soft delete
  INDEX identificador (identificador)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**Relaciones implícitas:**
- `nb_cargos.identificador` → `nb_reservas.identificador`
- `nb_pagos.identificador` → `nb_reservas.identificador`
- `nb_planespago_hoteles.id_hotel` → `nb_hoteles.id_hotel`
- `nb_planespago_habitaciones.id_habitacion` → `nb_habitaciones.id_habitacion`

**Flujo de pago típico:**
1. Se crea reserva → se genera `nb_cargos` con `estado='pendiente'`, `tipo_operacion='cobro'`
2. Worker procesa cargos pendientes → ejecuta TPV → inserta en `tpv_transaction`
3. Si éxito: actualiza `nb_cargos.estado='procesado'`, inserta `nb_pagos` con `metodo='tpv'`
4. Si error: `nb_cargos.estado='error'`, `nb_cargos.notas=<detalle error>`

---

#### **6. PRICING/INVENTORY (11 tablas)** - 2.0 GB
Sistema de pricing dinámico y gestión de disponibilidad.

**Tablas críticas:**
- `nb_precios_habitacion_combinacion` (17.2M filas, 1.5 GB) - **Precios pre-calculados por combinación (fecha, habitación, ocupación, estancia)**
- `nb_cupos` (6.5M filas, 346 MB) - **Disponibilidad real por fecha/habitación**
- `nb_paros_ventas` (842K filas, 104 MB) - Stop sales (cierres de venta)
- `nb_precios_habitacion` (66K filas, 6.5 MB)
- `nb_precios` (42K filas, 5 MB)
- `nb_precios_suplemento` (46K filas, 4.5 MB)
- `nb_precios_suplementos_estancia` (52K filas, 3.5 MB)
- `nb_paros_ventas_suplementos` (7.4K filas, 0.8 MB)
- `nb_paros_ventas_paquetes` (4.1K filas, 0.5 MB)
- `nb_paros_ventas_ofertas` (4.3K filas, 0.47 MB)
- `nb_paros_ventas_tipo` (110 filas, 0.03 MB)

**Estructura de nb_cupos (tabla crítica de disponibilidad):**
```sql
CREATE TABLE nb_cupos (
  -- NO HAY PRIMARY KEY EXPLÍCITA (ANTI-PATTERN GRAVE)
  id_hotel INT NOT NULL,
  id_habitacion INT NOT NULL,
  fecha DATE NOT NULL,
  cupo SMALLINT NOT NULL DEFAULT 0,  -- Disponibilidad
  id_precio INT NULL DEFAULT 0,  -- FK implícita a nb_precios
  last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  last_update_paros TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
  -- Sin índices visibles en metadata (requiere SHOW CREATE TABLE)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**HALLAZGO CRÍTICO:** `nb_cupos` NO tiene PRIMARY KEY explícita visible en información_schema. Esto es un anti-pattern GRAVE:
- Sin PK → Sin clustered index → Tabla es un heap (MySQL usa row ID interno)
- Performance degradada en queries frecuentes
- Posible que tenga índice UNIQUE no declarado como PK

**Estructura de nb_precios_habitacion_combinacion:**
```sql
-- Tabla de precios pre-calculados (denormalización por performance)
CREATE TABLE nb_precios_habitacion_combinacion (
  id_hotel INT NOT NULL,
  id_habitacion INT NOT NULL,
  fecha_entrada DATE NOT NULL,
  ocupacion TINYINT NOT NULL,  -- Número de personas
  estancia TINYINT NOT NULL,   -- Noches
  precio DECIMAL(10,2) NOT NULL,
  -- Índices: requiere análisis con SHOW CREATE TABLE
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**Patrón de pricing:**
1. **Precios base:** `nb_precios`, `nb_precios_habitacion`
2. **Pre-cálculo:** Job nocturno calcula precios por combinación → `nb_precios_habitacion_combinacion`
3. **Consulta real-time:** Query sobre tabla pre-calculada (trade-off: espacio por velocidad)
4. **Modificadores:** `nb_suplementos_precios`, `nb_precios_suplementos_estancia`

**Relaciones implícitas:**
- `nb_cupos.id_habitacion` → `nb_habitaciones.id_habitacion`
- `nb_cupos.id_hotel` → `nb_hoteles.id_hotel`
- `nb_cupos.id_precio` → `nb_precios.id_precio`
- `nb_paros_ventas.id_hotel` → `nb_hoteles.id_hotel`

---

#### **7. OFERTAS/PAQUETES (11 tablas)** - 110 MB

**Tablas:**
- `nb_ofertas` (90K filas, 17 MB)
- `nb_ofertas.lang` (1.2M filas, 56.6 MB) - Traducciones
- `nb_ofertas_disponibilidad` (103K filas, 11 MB)
- `nb_ofertas_condiciones` (82K filas, 7 MB)
- `nb_ofertas_acciones` (14K filas, 1.9 MB)
- `nb_paquetes` (6.4K filas, 1.6 MB)
- `nb_paquetes.lang` (99K filas, 13.5 MB)
- `nb_paquetes_habitaciones` (15K filas, 1.5 MB) - M:N paquetes-habitaciones
- `nb_paquetes_suplementos` (10K filas, 0.5 MB)
- `nb_paquetes_categorias` (86 filas, 0.02 MB)
- `nb_paquetes_categorias.lang` (1.3K filas, 0.08 MB)

**Soft delete pattern:**
```sql
nb_ofertas.activa ENUM('si','no') DEFAULT 'si'
nb_ofertas.eliminada ENUM('si','no') DEFAULT 'no'
```

---

#### **8. POLÍTICAS (8 tablas)** - 6.9 MB

**Tablas:**
- `nb_politicas` (2,040 filas, 0.41 MB)
- `nb_politicas_textos` (1,990 filas, 0.23 MB)
- `nb_politicas_textos.lang` (25K filas, 5.5 MB)
- `nb_politicas_ofertas` (5.4K filas, 0.42 MB)
- `nb_politicas_paquetes` (2.3K filas, 0.2 MB)
- `nb_politicas_habitaciones` (1.8K filas, 0.17 MB)
- `nb_politicas_hoteles` (1.7K filas, 0.14 MB)
- `nb_politicas_entradas` (2.9K filas, 0.14 MB)

---

#### **9. SUPLEMENTOS (4 tablas)** - 17.9 MB

**Tablas:**
- `nb_suplementos` (10.9K filas, 2 MB)
- `nb_suplementos.lang` (158K filas, 12.5 MB)
- `nb_suplementos_precios` (18.6K filas, 3 MB)
- `nb_suplementos_habitaciones` (11.4K filas, 0.34 MB) - M:N

---

#### **10. FOTOS (12 tablas)** - 70 MB

**Tablas:**
- `nb_fotos_habitaciones` (76K filas, 18 MB)
- `nb_fotos_habitaciones.lang` (898K filas, 25.6 MB)
- `nb_fotos` (16K filas, 4.9 MB)
- `nb_fotos.lang` (248K filas, 7.5 MB)
- `nb_fotos_ambientes`, `nb_fotos_paquetes`, `nb_fotos_suplementos`, `nb_fotos_ofertas` (+ .lang)

---

#### **11. NEWSLETTERS (7 tablas)** - 1.4 GB

**Tablas:**
- `nb_mod_newsletters_stats` (5.3M filas, 1.2 GB) - Estadísticas de envío/apertura
- `nb_mod_newsletters.lang` (43K filas, 139 MB)
- `nb_mod_newsletters` (2K filas, 0.36 MB)
- `nb_mod_newsletters_media` (3.4K filas, 1.6 MB)
- `nb_mod_newsletters_errors` (3.3K filas, 0.36 MB)
- `nb_mod_newsletters_condiciones` (4.8K filas, 0.36 MB)
- `nb_mod_newsletters_emails` (0 filas, 0.06 MB) - Vacía

---

#### **12. USUARIOS (3 tablas)** - 2 MB

**Tablas legacy:**
- `nb_usuarios` (2,887 filas, 1.95 MB) - **Usuarios del sistema (empleados)**
- `nb_gestores` (12 filas, 0.02 MB)
- `nb_usuarios_gcm` (0 filas, vacía)

**Tablas nuevas:**
- `user` (1,275 filas, 0.34 MB)
- `user_hotel` (11.6K filas, 0.36 MB)
- `user_message` (71K filas, 3.5 MB)
- `user_rewards` (328K filas, 39.6 MB) - Sistema de fidelización
- `user_rewards_hotel` (341K filas, 18.6 MB)
- `user_group` (0 filas, vacía)

**Estructura nb_usuarios:**
```sql
CREATE TABLE nb_usuarios (
  login VARCHAR(50) NOT NULL PRIMARY KEY,  -- Email como PK (ANTI-PATTERN)
  pass VARCHAR(32) NOT NULL,  -- MD5 hash (ANTI-PATTERN CRÍTICO DE SEGURIDAD)
  nif VARCHAR(10) NOT NULL UNIQUE,
  nombre VARCHAR(50) NOT NULL,
  apellidos VARCHAR(100) NOT NULL,
  telefono VARCHAR(15) NOT NULL,
  grupo ENUM(...) NOT NULL,
  id_cadena INT NULL,  -- FK implícita
  idioma CHAR(2) NOT NULL DEFAULT 'es',
  activo ENUM('si','no') NOT NULL DEFAULT 'no',
  -- ...
  INDEX grupo (grupo),
  INDEX id_cadena (id_cadena)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**ANTI-PATTERN SEGURIDAD CRÍTICA:**
- Password hash de 32 caracteres = MD5 (inseguro desde 2004)
- Sin salt, sin iteraciones, vulnerable a rainbow tables
- **RECOMENDACIÓN URGENTE:** Migrar a bcrypt/argon2 (60+ caracteres)

**Relación dual usuario:**
- `nb_usuarios` → Usuarios internos (staff hotelero)
- `user` → Posible nuevo sistema de usuarios (clientes/staff unificado)
- `nb_hoteles_usuario` → M:N permisos de usuario a hoteles

---

#### **13. CORE_OTROS (49 tablas)** - 5.6 GB

**Tablas destacadas:**
- `nb_notas` (24.4M filas, 4.2 GB) - **Notas/comentarios en reservas/entidades**
- `nb_acciones` (7.2M filas, 1.2 GB) - **Log de acciones de usuario**
- `nb_alertas` (1.5M filas, 142 MB)
- `nb_configuraciones` (180K filas, 11.6 MB) - **KV store de configuraciones**
- `nb_ip2country` (302K filas, 9.5 MB) - Geolocalización IP
- `nb_capacidad_habitacion` (62.6K filas, 2.5 MB)
- `nb_cadenas` (201 filas, 0.08 MB)
- `nb_grupos` (240 filas, 0.08 MB)
- `nb_paises` (250 filas, 0.02 MB)
- `nb_provincias` (3,806 filas, 0.19 MB)
- `nb_currencies` (182 filas, 0.05 MB)
- `nb_languages` (184 filas, 0.02 MB)
- `nb_zonas` (492 filas, 0.08 MB)
- `nb_portales` (121 filas, 0.02 MB)
- `nb_categorias` (75 filas, 0.02 MB) - Categorías de hotel (estrellas)
- Tablas `nb_idsglobales_*` - Mapeos globales para integraciones
- Programas fidelización: `nb_programas_fidelizacion`, `nb_programas_neoloyalty_*`
- Tasas turísticas: `nb_tasas_turisticas`
- Datos fiscales: `nb_datos_fiscales`

**Estructura nb_notas:**
```sql
CREATE TABLE nb_notas (
  id_nota INT AUTO_INCREMENT PRIMARY KEY,
  identificador VARCHAR(13) NOT NULL,  -- Puede ser reserva u otra entidad
  tipo VARCHAR(50),  -- Tipo de entidad relacionada
  texto TEXT,
  usuario VARCHAR(50),
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX identificador (identificador)
) ENGINE=InnoDB;
```

**Estructura nb_acciones (audit log):**
```sql
CREATE TABLE nb_acciones (
  id_accion INT AUTO_INCREMENT PRIMARY KEY,
  id_objeto INT NOT NULL,  -- ID de la entidad modificada
  tipo VARCHAR(50) NOT NULL,  -- Tipo de objeto (reserva, hotel, etc)
  accion VARCHAR(50) NOT NULL,  -- Tipo de acción (crear, modificar, eliminar)
  usuario VARCHAR(50),
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  datos TEXT  -- Posible snapshot de cambios
) ENGINE=InnoDB;
```

---

#### **14. WEBSERVICES (6 tablas)** - 451 MB

**Tablas:**
- `nb_mod_ws_notifications` (6.6M filas, 450 MB) - Log de notificaciones WS
- `nb_mod_ws_stopsales` (4.1K filas, 0.77 MB)
- `nb_mod_ws_metodos_usuario` (4.4K filas, 0.36 MB)
- `nb_mod_ws` (14 filas, 0.02 MB)
- `nb_mod_ws_metodos` (62 filas, 0.03 MB)
- `nb_mod_ws_stats` (0 filas, vacía)

---

#### **15. PRODUCTOS (9 tablas)** - 0.3 MB
Sistema de productos adicionales vendibles (spa, tours, etc).

---

#### **16. TRASLADOS (11 tablas)** - 1.9 MB
Sistema de traslados aeropuerto-hotel.

---

#### **17. INFRASTRUCTURE (10 tablas)** - 13 MB

**Tablas:**
- `config_steps` (528 filas, 10.5 MB) - Configuración wizard setup
- `domains` (362 filas, 1.5 MB)
- `client` (462 filas, 0.08 MB)
- `hotel_template` (286 filas, 0.05 MB)
- `features` (58 filas, 0.02 MB)
- `features_cadenas` (359 filas, 0.05 MB)
- `features.lang`, `features_cadenas.lang`
- `currency` (172 filas, 0.02 MB)
- `updates`, `updates_log` (vacías)
- `api_endpoints` (vacía)

---

#### **18. TPV_EXTERNAL (2 tablas)** - 13.6 MB

**Tablas:**
- `tpv_transaction` (70K filas, 13.6 MB) - Transacciones TPV externo
- `tpv_tokens` (0 filas, vacía)

---

#### **19. BUDGET (1 tabla)** - 22.5 MB

**Tabla:**
- `budget` (500 filas, 22.5 MB) - Sistema de presupuestos

---

#### **20. SIN_CLASIFICAR (9 tablas)** - 8 MB

**Tablas:**
- `translations_steps` (36K filas, 3.5 MB)
- `performance_digests` (3.3K filas, 2.7 MB)
- `performance_stats` (24K filas, 1.5 MB)
- `client_chain`, `group`, `group_hotel`, `group_action`, `connect_node`

---

## PATRÓN DE INTERNACIONALIZACIÓN (i18n)

### Mecánica de Tablas `.lang`

**Total de tablas `.lang`:** 27 tablas
**Patrón:** `<tabla_principal>.lang`
**Tamaño total:** ~290 MB

**Estructura estándar:**
```sql
CREATE TABLE `nb_hoteles.lang` (
  id_hotel INT NOT NULL,
  language CHAR(2) NOT NULL,  -- Código ISO 639-1 (es, en, fr, de, it, pt, ca, etc)
  <columnas_traducibles> TEXT,
  PRIMARY KEY (id_hotel, language)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

**Ejemplo concreto (nb_hoteles.lang):**
- PK compuesta: `(id_hotel, language)`
- 19 columnas traducibles: `descripcion_hotel`, `condiciones_reserva`, `politica_cancelacion`, `politica_privacidad`, etc.
- 19,580 filas = ~1,610 hoteles × ~12 idiomas promedio
- **SIN FOREIGN KEY** a `nb_hoteles` ni a `nb_languages`

**Tablas con mayor volumen de traducciones:**
1. `nb_ofertas.lang` - 1.2M filas, 56.6 MB (ofertas promocionales)
2. `nb_fotos_habitaciones.lang` - 898K filas, 25.6 MB (descripciones de fotos)
3. `nb_fotos.lang` - 248K filas, 7.5 MB
4. `nb_habitaciones.lang` - 184K filas, 34.6 MB
5. `nb_suplementos.lang` - 158K filas, 12.5 MB

**Idiomas soportados (inferidos de nb_languages):**
- Principales: es (español), en (inglés), fr (francés), de (alemán), it (italiano), pt (portugués)
- Regionales: ca (catalán), eu (euskera), gl (gallego)
- Total: ~184 registros en `nb_languages`

**Consulta típica con i18n:**
```sql
SELECT
  h.id_hotel,
  h.nombre_hotel,
  hl.descripcion_hotel,
  hl.politica_cancelacion
FROM nb_hoteles h
LEFT JOIN `nb_hoteles.lang` hl ON h.id_hotel = hl.id_hotel AND hl.language = 'en'
WHERE h.activo = 'si';
```

**ANTI-PATTERN DETECTADO:**
- Nombre de tabla con punto: `nb_hoteles.lang` (válido en MySQL pero confuso, puede causar problemas en ORMs)
- Sin FK → integridad referencial en código
- Sin índice en `language` → queries filtradas por idioma hacen full scan de PK

**RECOMENDACIÓN:**
- Renombrar a `nb_hoteles_lang` (underscore en lugar de punto)
- Agregar FK: `FOREIGN KEY (id_hotel) REFERENCES nb_hoteles(id_hotel) ON DELETE CASCADE`
- Agregar FK: `FOREIGN KEY (language) REFERENCES nb_languages(codigo) ON DELETE RESTRICT`

---

## PATRONES DE DISEÑO DETECTADOS

### 1. SOFT DELETE (Múltiples Variantes)

**Patrón A: Columna `eliminada` (ENUM)**
```sql
eliminada ENUM('si','no') NOT NULL DEFAULT 'no'
```
**Tablas:** `nb_habitaciones`, `nb_ofertas`, `nb_suplementos`

**Patrón B: Columna `eliminado` (TINYINT)**
```sql
eliminado TINYINT NOT NULL DEFAULT 0
```
**Tablas:** `nb_pagos`, `nb_paquetes`, `nb_banners`, `nb_mod_productos`

**Patrón C: Columna `activa/activo` (ENUM o TINYINT)**
```sql
activa ENUM('si','no') NOT NULL DEFAULT 'si'
activo TINYINT NOT NULL DEFAULT 0
```
**Tablas:** `nb_habitaciones`, `nb_hoteles`, `nb_ofertas`, `nb_politicas`, `nb_suplementos`, `nb_planespago`, `nb_mod_newsletters`

**Patrón D: Triple soft delete (nb_habitaciones)**
```sql
activa ENUM('si','no') NOT NULL DEFAULT 'si',
visible ENUM('si','no') NOT NULL DEFAULT 'si',
eliminada ENUM('si','no') NOT NULL DEFAULT 'no'
```
**Lógica de negocio compleja:**
- `eliminada='si'` → Borrado permanente (no se muestra nunca)
- `activa='no'` → Desactivada temporalmente (no se puede reservar pero se ve en backend)
- `visible='no'` → Oculta en frontend pero activa en backend

**INCONSISTENCIA CRÍTICA:**
- No hay patrón unificado
- 3 nombres diferentes: `eliminada`, `eliminado`, `activo/activa`
- 2 tipos de datos: ENUM vs TINYINT
- Lógica de negocio varía por tabla

**RECOMENDACIÓN ARQUITECTÓNICA:**
Estandarizar con patrón moderno:
```sql
deleted_at TIMESTAMP NULL DEFAULT NULL,
INDEX idx_deleted_at (deleted_at)
```
**Ventajas:**
- Auditoría: saber CUÁNDO se eliminó
- Queries: `WHERE deleted_at IS NULL` (activos) vs `WHERE deleted_at IS NOT NULL` (eliminados)
- Reversible: solo actualizar a NULL para recuperar
- Estándar: usado por Laravel, Rails, Django

---

### 2. TIMESTAMPS DE AUDITORÍA

**Patrón estándar (95% de las tablas):**
```sql
last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

**Patrón completo (algunas tablas):**
```sql
timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,  -- Creación
last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  -- Modificación
```

**Tablas con auditoría completa:**
- `nb_reservas`: `timestamp` (creación) + `last_update` (modificación)
- `nb_cargos`: `fecha_creacion` + `fecha_ejecucion`
- `nb_reservas_tracking`: `timestamp`, `confirmado`, `realizado`, `cancelado`, `last_update` (5 timestamps)
- `budget`: 6 timestamps diferentes (arrival, departure, sent_date, copied_date, creation_date, last_update)

**FALTA:** Columna `created_at` explícita en mayoría de tablas. Solo tienen `last_update`.

**Tablas SIN timestamps (vacías o sin auditoría):**
- `nb_log`, `nb_sessions`, `nb_cuentasbancarias`, `nb_tarjetascredito`, `nb_tpv`, `tpv_tokens`, `updates`, `updates_log`, `group`, `group_hotel`, `group_action`, `user_group`

**RECOMENDACIÓN:**
Estandarizar con patrón Laravel:
```sql
created_at TIMESTAMP NULL DEFAULT NULL,
updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
INDEX idx_created_at (created_at),
INDEX idx_updated_at (updated_at)
```

---

### 3. ESTADOS Y WORKFLOWS (ENUM)

**Reservas (nb_reservas):**
```sql
estado ENUM('confirmada','cancelada','nula') DEFAULT 'confirmada'
revisada ENUM('si','no') DEFAULT 'no'
autorizacion ENUM('si','no') NULL
metodo_pago ENUM('tpv','tarjeta','transferencia','efectivo','credito','giro_postal','paypal','otb','financiado','otro') DEFAULT 'otro'
tipo_pago ENUM('completo','noche','porcentaje','ninguno') DEFAULT 'ninguno'
```

**Cargos (nb_cargos):**
```sql
estado ENUM('informativo','hotel','online','pendiente','procesado','cancelado','error')
tipo_operacion ENUM('preautorizacion','cobro','devolucion')
```

**Pagos (nb_pagos):**
```sql
metodo ENUM('tpv','tpv-manual','transferencia','efectivo','credito','paypal','otb','financiado','otro') DEFAULT 'tpv'
```

**Habitaciones:**
```sql
activa ENUM('si','no') DEFAULT 'si'
visible ENUM('si','no') DEFAULT 'si'
eliminada ENUM('si','no') DEFAULT 'no'
permitir_upgrade ENUM('always','never') DEFAULT 'always'
facturacion ENUM('pax','alojamiento') NULL
```

**Hoteles:**
```sql
activo ENUM('si','no') DEFAULT 'no'
acepta_bebes ENUM('si','no') DEFAULT 'si'
acepta_ninos ENUM('si','no') DEFAULT 'si'
pago_hotel ENUM('si','no') DEFAULT 'no'
pago_fraccionado ENUM('no','noche','porcentaje','fijo','hotel') DEFAULT 'noche'
```

**VENTAJA:** Constraints a nivel de base de datos (solo valores válidos)
**DESVENTAJA:** Cambiar valores requiere ALTER TABLE (migración costosa en producción)

**ALTERNATIVA MODERNA:**
- Usar VARCHAR + CHECK constraint (MySQL 8.0.16+)
- Usar tabla de referencia: `nb_estados_reserva` (id, codigo, descripcion)
- Permite agregar estados sin ALTER TABLE

---

### 4. RELACIONES IMPLÍCITAS (Sin FK)

**Total de Foreign Keys explícitas:** 0 (CERO)
**Total de relaciones implícitas detectadas:** 200+

**Convenciones de naming:**

**A) Columnas `id_<entidad>`**
```
id_hotel → nb_hoteles.id_hotel
id_habitacion → nb_habitaciones.id_habitacion
id_cadena → nb_cadenas.id_cadena
id_usuario → nb_usuarios.login (inconsistente: debería ser id_usuario INT)
id_oferta → nb_ofertas.id_oferta
id_paquete → nb_paquetes.id_paquete
id_politica → nb_politicas.id_politica
id_suplemento → nb_suplementos.id_suplemento
```

**B) Columna `identificador` (VARCHAR)**
```
nb_reservas.identificador (PK) ← nb_reservas_habitaciones.identificador
nb_reservas.identificador (PK) ← nb_pagos.identificador
nb_reservas.identificador (PK) ← nb_cargos.identificador
nb_reservas.identificador (PK) ← nb_notas.identificador
nb_reservas.identificador (PK) ← nb_reservas_canales.identificador
```

**C) Códigos ISO (relaciones a catálogos)**
```
pais CHAR(2) → nb_paises (ES, FR, DE, IT, GB, etc)
moneda CHAR(3) → nb_currencies (EUR, USD, GBP, etc)
idioma CHAR(2) → nb_languages (es, en, fr, de, it, etc)
```

**D) Relaciones M:N (tablas puente)**
```
nb_hoteles_usuario: (login, id_hotel) → M:N entre nb_usuarios y nb_hoteles
nb_habitaciones_ambientes: (id_habitacion, id_ambiente) → M:N
nb_paquetes_habitaciones: (id_paquete, id_habitacion) → M:N
nb_paquetes_suplementos: (id_paquete, id_suplemento) → M:N
nb_suplementos_habitaciones: (id_suplemento, id_habitacion) → M:N
nb_politicas_hoteles: (id_politica, id_hotel) → M:N
nb_politicas_habitaciones: (id_politica, id_habitacion) → M:N
nb_politicas_ofertas: (id_politica, id_oferta) → M:N
nb_planespago_hoteles: (id_planpago, id_hotel) → M:N
```

**Relaciones críticas sin FK:**

**1. nb_reservas → nb_hoteles**
```sql
-- Relación implícita a través de nb_reservas_habitaciones
nb_reservas.identificador → nb_reservas_habitaciones.identificador
nb_reservas_habitaciones.id_hotel_rh → nb_hoteles.id_hotel
```

**2. nb_reservas_habitaciones → nb_habitaciones**
```sql
nb_reservas_habitaciones.id_habitacion → nb_habitaciones.id_habitacion
nb_reservas_habitaciones.id_hotel_rh → nb_hoteles.id_hotel
```

**3. nb_habitaciones → nb_hoteles**
```sql
nb_habitaciones.id_hotel → nb_hoteles.id_hotel
```

**4. nb_habitaciones → nb_habitaciones (self-join para variantes)**
```sql
nb_habitaciones.id_principal → nb_habitaciones.id_habitacion
```

**5. nb_cupos → nb_habitaciones + nb_precios**
```sql
nb_cupos.id_habitacion → nb_habitaciones.id_habitacion
nb_cupos.id_hotel → nb_hoteles.id_hotel
nb_cupos.id_precio → nb_precios.id_precio
```

**6. nb_mod_channels_inventory → nb_habitaciones**
```sql
nb_mod_channels_inventory.roomId → nb_habitaciones.id_habitacion
nb_mod_channels_inventory.id_hotel → nb_hoteles.id_hotel
```

**IMPACTO DE AUSENCIA DE FKs:**

**Ventajas (razones por las que podrían haberlo hecho así):**
- Flexibilidad: permite insertar datos sin orden estricto
- Performance: evita overhead de validación de FK en INSERT/UPDATE
- Desarrollo rápido: no requiere planificar dependencias
- Sharding futuro: FKs dificultan particionamiento horizontal

**Desventajas (riesgos reales):**
- **Datos huérfanos:** Reservas con id_hotel inexistente
- **Inconsistencias:** Eliminar hotel no elimina/marca habitaciones
- **Debugging complejo:** No se puede confiar en integridad
- **Sin cascadas:** DELETE/UPDATE cascade debe hacerse en código
- **Queries más lentas:** Optimizer no puede usar FK para optimizar JOINs
- **Documentación implícita:** Relaciones no auto-documentadas en schema

**RECOMENDACIÓN PRAGMÁTICA:**

**Fase 1 (Quick Wins - 0 downtime):**
Agregar FKs en tablas pequeñas/catálogos:
```sql
ALTER TABLE nb_habitaciones
  ADD CONSTRAINT fk_habitaciones_hotel
  FOREIGN KEY (id_hotel) REFERENCES nb_hoteles(id_hotel)
  ON DELETE RESTRICT ON UPDATE CASCADE;

ALTER TABLE nb_usuarios
  ADD CONSTRAINT fk_usuarios_cadena
  FOREIGN KEY (id_cadena) REFERENCES nb_cadenas(id_cadena)
  ON DELETE SET NULL ON UPDATE CASCADE;
```

**Fase 2 (Validación previa):**
Antes de agregar FKs en tablas grandes, validar integridad:
```sql
-- Detectar reservas huérfanas
SELECT DISTINCT rh.id_hotel_rh
FROM nb_reservas_habitaciones rh
LEFT JOIN nb_hoteles h ON rh.id_hotel_rh = h.id_hotel
WHERE h.id_hotel IS NULL;

-- Detectar habitaciones huérfanas
SELECT id_habitacion, id_hotel
FROM nb_habitaciones hab
LEFT JOIN nb_hoteles hot ON hab.id_hotel = hot.id_hotel
WHERE hot.id_hotel IS NULL;
```

**Fase 3 (Limpieza + FK en tablas grandes):**
1. Limpiar datos huérfanos
2. Agregar FKs progresivamente en ventanas de mantenimiento
3. Priorizar: nb_reservas_habitaciones, nb_cupos, nb_precios_habitacion

---

### 5. DENORMALIZACIÓN ESTRATÉGICA

**Caso 1: nb_precios_habitacion_combinacion (17.2M filas)**
- **Qué denormaliza:** Pre-calcula precios por (fecha, habitación, ocupación, estancia)
- **Por qué:** Query real-time de pricing sería costosísimo (múltiples JOINs + cálculos)
- **Trade-off:** 1.5 GB de espacio a cambio de queries <50ms vs >2000ms
- **Mantenimiento:** Job nocturno regenera precios modificados

**Caso 2: nb_reservas_desgloses (5.3M filas, 22 GB)**
- **Qué denormaliza:** Desglose de precio total de reserva por noche/concepto
- **Por qué:** Auditoría, facturación, informes financieros
- **Trade-off:** 22 GB a cambio de no recalcular breakdown en cada query

**Caso 3: id_hotel_rh en nb_reservas_habitaciones**
- **Qué denormaliza:** Duplica id_hotel (ya está en nb_habitaciones)
- **Por qué:** Evita JOIN adicional en queries frecuentes
- **Ejemplo:**
```sql
-- Sin denormalización (2 JOINs)
SELECT r.*, rh.*, hab.*, h.*
FROM nb_reservas r
JOIN nb_reservas_habitaciones rh ON r.identificador = rh.identificador
JOIN nb_habitaciones hab ON rh.id_habitacion = hab.id_habitacion
JOIN nb_hoteles h ON hab.id_hotel = h.id_hotel;

-- Con denormalización (1 JOIN menos)
SELECT r.*, rh.*, h.*
FROM nb_reservas r
JOIN nb_reservas_habitaciones rh ON r.identificador = rh.identificador
JOIN nb_hoteles h ON rh.id_hotel_rh = h.id_hotel;
```

**Patrón detectado:** Denormalización orientada a performance de queries críticas, asumiendo costo de sincronización en escritura.

---

## ANÁLISIS DE ÍNDICES

### Índices Estratégicos Detectados

**1. Índices compuestos en nb_reservas:**
```sql
INDEX estado (estado, email)  -- Query: buscar reservas canceladas de un email
INDEX id_hotel_r (gastos_emision, last_update)  -- Query: reportes financieros recientes
INDEX last_update (last_update, timestamp)  -- Query: cambios recientes
```

**2. Índices compuestos en nb_reservas_habitaciones:**
```sql
INDEX identificador (id_hotel_rh, identificador)  -- Query: habitaciones de reserva por hotel
INDEX id_habitacion (id_habitacion, fecha_entrada, fecha_salida)  -- Query: ocupación de habitación en rango de fechas
```

**3. Índices en nb_mod_channels_inventory (tabla más indexada):**
```sql
PRIMARY KEY (arrival, id_hotel, roomId, channel, portal, nights)  -- PK compuesta de 6 columnas
INDEX id_hotel (id_hotel, pending)  -- Query: pendientes de sincronización por hotel
INDEX id_hotel_2 (id_hotel, arrival)  -- Query: inventario desde fecha
INDEX pending (pending, error, id_hotel, quantity)  -- Query: cola de errores de sincronización
INDEX last_update (last_update)  -- Query: cambios recientes
INDEX status (status)  -- Query: filtro por estado
INDEX priority (priority, sendError)  -- Query: reintentos priorizados
INDEX roomId (roomId)  -- Query: lookup inverso por habitación
```

**Total de índices en nb_mod_channels_inventory:** 8 (incluido PK)
**Tamaño de índices:** 5.1 GB (80% del tamaño total de la tabla)
**Ratio índices/datos:** 4.4:1 (altísimo, justificado por queries intensivas)

**4. Índices faltantes (detectados por análisis):**

**A) nb_reservas.pais, moneda, idioma (catálogos)**
```sql
-- Actualmente SIN índice
-- Queries frecuentes de reporting por país/moneda
SELECT COUNT(*), SUM(precio_total)
FROM nb_reservas
WHERE pais = 'ES' AND estado = 'confirmada'
GROUP BY moneda;

-- Recomendación:
CREATE INDEX idx_pais_moneda ON nb_reservas(pais, moneda);
```

**B) nb_habitaciones.id_global (mapeo de canales)**
```sql
-- Actualmente SIN índice
-- Queries de sincronización de canales buscan por id_global
SELECT id_habitacion, id_hotel
FROM nb_habitaciones
WHERE id_global = 'GHPA_12345';

-- Recomendación:
CREATE UNIQUE INDEX idx_id_global ON nb_habitaciones(id_global);
```

**C) nb_cupos.fecha (queries de disponibilidad)**
```sql
-- Estado actual desconocido (requiere SHOW CREATE TABLE)
-- Query crítica de disponibilidad:
SELECT cupo
FROM nb_cupos
WHERE id_habitacion = 123 AND fecha BETWEEN '2025-01-01' AND '2025-01-31';

-- Recomendación (si no existe):
CREATE INDEX idx_habitacion_fecha ON nb_cupos(id_habitacion, fecha);
```

**D) Columnas JSON sin índices generados (MySQL 5.7+)**
```sql
-- nb_reservas.datos, nb_reservas.disfrute_productos (JSON)
-- nb_pagos.neopayments_data (JSON)

-- Si hay queries frecuentes sobre campos JSON específicos:
ALTER TABLE nb_reservas
  ADD COLUMN origen_ads_extracted VARCHAR(255)
  AS (JSON_UNQUOTE(JSON_EXTRACT(datos, '$.origen_ads'))) VIRTUAL,
  ADD INDEX idx_origen_ads (origen_ads_extracted);
```

---

## RECOMENDACIONES ARQUITECTÓNICAS

### CRÍTICAS (Implementar en 0-3 meses)

**1. AÑADIR FOREIGN KEYS EN TABLAS CRÍTICAS**

**Impacto:** CRÍTICO
**Esfuerzo:** MEDIO
**Riesgo:** BAJO (si se valida integridad previa)

**Plan de ejecución:**

**Fase 1: Validación (2 semanas)**
```sql
-- Script de validación de integridad
-- Ejecutar en READ REPLICA para no impactar producción

-- 1. Detectar hoteles huérfanos en nb_habitaciones
SELECT COUNT(*) as huerfanos
FROM nb_habitaciones hab
LEFT JOIN nb_hoteles hot ON hab.id_hotel = hot.id_hotel
WHERE hot.id_hotel IS NULL;

-- 2. Detectar habitaciones huérfanas en nb_reservas_habitaciones
SELECT COUNT(*) as huerfanos
FROM nb_reservas_habitaciones rh
LEFT JOIN nb_habitaciones hab ON rh.id_habitacion = hab.id_habitacion
WHERE hab.id_habitacion IS NULL;

-- 3. Detectar reservas huérfanas en nb_reservas_habitaciones
SELECT COUNT(*) as huerfanos
FROM nb_reservas_habitaciones rh
LEFT JOIN nb_reservas r ON rh.identificador = r.identificador
WHERE r.identificador IS NULL;

-- 4. Detectar cadenas huérfanas en nb_hoteles
SELECT COUNT(*) as huerfanos
FROM nb_hoteles h
LEFT JOIN nb_cadenas c ON h.id_cadena = c.id_cadena
WHERE h.id_cadena IS NOT NULL AND c.id_cadena IS NULL;
```

**Fase 2: Limpieza de datos huérfanos (1-2 semanas)**
```sql
-- Opción A: Marcar como eliminados (soft delete)
UPDATE nb_habitaciones hab
LEFT JOIN nb_hoteles hot ON hab.id_hotel = hot.id_hotel
SET hab.eliminada = 'si', hab.activa = 'no'
WHERE hot.id_hotel IS NULL;

-- Opción B: Asignar a hotel "dummy" (si no se pueden eliminar)
INSERT INTO nb_hoteles (nombre_hotel, activo) VALUES ('HOTEL_HUERFANO_TEMPORAL', 'no');
SET @hotel_dummy = LAST_INSERT_ID();

UPDATE nb_habitaciones hab
LEFT JOIN nb_hoteles hot ON hab.id_hotel = hot.id_hotel
SET hab.id_hotel = @hotel_dummy
WHERE hot.id_hotel IS NULL;
```

**Fase 3: Implementación de FKs (1-2 semanas, ventanas de mantenimiento)**
```sql
-- FK 1: nb_habitaciones → nb_hoteles
ALTER TABLE nb_habitaciones
  ADD CONSTRAINT fk_habitaciones_hotel
  FOREIGN KEY (id_hotel) REFERENCES nb_hoteles(id_hotel)
  ON DELETE RESTRICT  -- No permitir eliminar hotel con habitaciones
  ON UPDATE CASCADE;  -- Si se cambia id_hotel (raro), actualizar referencias

-- FK 2: nb_reservas_habitaciones → nb_habitaciones
ALTER TABLE nb_reservas_habitaciones
  ADD CONSTRAINT fk_reservas_hab_habitacion
  FOREIGN KEY (id_habitacion) REFERENCES nb_habitaciones(id_habitacion)
  ON DELETE RESTRICT
  ON UPDATE CASCADE;

-- FK 3: nb_reservas_habitaciones → nb_reservas
ALTER TABLE nb_reservas_habitaciones
  ADD CONSTRAINT fk_reservas_hab_reserva
  FOREIGN KEY (identificador) REFERENCES nb_reservas(identificador)
  ON DELETE CASCADE  -- Si se elimina reserva, eliminar líneas de habitación
  ON UPDATE CASCADE;

-- FK 4: nb_hoteles → nb_cadenas (permitir NULL)
ALTER TABLE nb_hoteles
  ADD CONSTRAINT fk_hoteles_cadena
  FOREIGN KEY (id_cadena) REFERENCES nb_cadenas(id_cadena)
  ON DELETE SET NULL  -- Si se elimina cadena, poner NULL en hoteles
  ON UPDATE CASCADE;

-- FK 5: nb_usuarios → nb_cadenas
ALTER TABLE nb_usuarios
  ADD CONSTRAINT fk_usuarios_cadena
  FOREIGN KEY (id_cadena) REFERENCES nb_cadenas(id_cadena)
  ON DELETE SET NULL
  ON UPDATE CASCADE;

-- FK 6: nb_pagos → nb_reservas
ALTER TABLE nb_pagos
  ADD CONSTRAINT fk_pagos_reserva
  FOREIGN KEY (identificador) REFERENCES nb_reservas(identificador)
  ON DELETE RESTRICT  -- No permitir eliminar reserva con pagos
  ON UPDATE CASCADE;

-- FK 7: nb_cargos → nb_reservas
ALTER TABLE nb_cargos
  ADD CONSTRAINT fk_cargos_reserva
  FOREIGN KEY (identificador) REFERENCES nb_reservas(identificador)
  ON DELETE RESTRICT
  ON UPDATE CASCADE;
```

**Monitoring post-implementación:**
```sql
-- Verificar que FKs están activas
SELECT
  TABLE_NAME,
  CONSTRAINT_NAME,
  REFERENCED_TABLE_NAME,
  REFERENCED_COLUMN_NAME
FROM information_schema.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'neobookings_latest'
AND REFERENCED_TABLE_NAME IS NOT NULL;

-- Monitor de violaciones de FK (si hay intentos de inserción inválida)
SHOW ENGINE INNODB STATUS\G
-- Buscar sección "LATEST FOREIGN KEY ERROR"
```

**Impacto esperado:**
- Integridad garantizada a nivel DB (elimina clase completa de bugs)
- Queries más rápidas (optimizer usa FK para optimizar JOINs)
- Documentación implícita de relaciones
- Posibles errores al insertar datos inválidos (FEATURE, no bug)

---

**2. MIGRAR nb_reservas.identificador DE VARCHAR A BIGINT**

**Impacto:** ALTO
**Esfuerzo:** ALTO
**Riesgo:** MEDIO-ALTO (requiere migración de 6.9M filas + todas las tablas relacionadas)

**Problema actual:**
```sql
nb_reservas.identificador VARCHAR(13) PRIMARY KEY
-- Ejemplo de valor: "RS2025110001"
```

**Problemas:**
- 13 bytes por clave vs 8 bytes (BIGINT) = 62% overhead
- Comparación de strings en JOINs (lento vs enteros)
- Fragmentación del clustered index InnoDB
- Sin AUTO_INCREMENT (generación en código)

**Solución propuesta:**
```sql
-- Nueva estructura
nb_reservas.id_reserva BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
nb_reservas.codigo_reserva VARCHAR(13) UNIQUE NOT NULL  -- Mantener código legible para usuarios

-- BIGINT UNSIGNED rango: 0 a 18,446,744,073,709,551,615
-- Con 6.9M reservas actuales + crecimiento de 1M/año → 18,000 años de margen
```

**Plan de migración (COMPLEJO, requiere planificación detallada):**

**Opción A: Migración en caliente (Blue-Green Deployment)**
1. Crear nueva columna `id_reserva BIGINT` en nb_reservas
2. Generar IDs para filas existentes (script batch)
3. Actualizar código aplicación para usar ambas claves (transición)
4. Crear nuevas tablas relacionadas con BIGINT FK
5. Migrar datos de tablas antiguas a nuevas (batch)
6. Switchover: apuntar aplicación a nuevas tablas
7. Eliminar tablas antiguas tras validación

**Opción B: Migración offline (Ventana de mantenimiento larga)**
1. Programar ventana de 4-8 horas
2. Congelar escrituras (modo READ-ONLY)
3. Ejecutar ALTER TABLE masivo
4. Actualizar código aplicación
5. Descongelar escrituras

**Costo estimado:** 40-60 horas de desarrollo + testing + migración
**Beneficio:** 30-40% mejora en queries de JOIN con reservas, reducción de 2-3 GB en índices

**Decisión recomendada:** Postponer hasta que sea bloqueante (ej: performance insostenible). Priorizar FKs primero.

---

**3. ESTANDARIZAR SOFT DELETES**

**Impacto:** MEDIO
**Esfuerzo:** MEDIO
**Riesgo:** BAJO

**Situación actual:**
- `eliminada ENUM('si','no')` en nb_habitaciones, nb_ofertas
- `eliminado TINYINT` en nb_pagos, nb_paquetes
- `activa/activo ENUM/TINYINT` en nb_hoteles, nb_politicas, nb_suplementos
- Triple soft delete en nb_habitaciones: `activa`, `visible`, `eliminada`

**Solución propuesta:**
```sql
-- Patrón moderno (Laravel/Rails/Django)
ALTER TABLE <tabla>
  ADD COLUMN deleted_at TIMESTAMP NULL DEFAULT NULL,
  ADD INDEX idx_deleted_at (deleted_at);
```

**Ventajas:**
- Auditoría: saber CUÁNDO se eliminó (no solo SI/NO)
- Queries unificadas: `WHERE deleted_at IS NULL` (activos)
- Recuperación: `UPDATE ... SET deleted_at = NULL` (reversible)
- Estándar: compatible con ORMs modernos

**Plan de migración:**
```sql
-- Paso 1: Agregar columna nueva (sin eliminar antigua)
ALTER TABLE nb_habitaciones
  ADD COLUMN deleted_at TIMESTAMP NULL DEFAULT NULL,
  ADD INDEX idx_deleted_at (deleted_at);

-- Paso 2: Migrar datos (ejemplo para eliminada='si')
UPDATE nb_habitaciones
SET deleted_at = last_update  -- Usar last_update como aproximación
WHERE eliminada = 'si';

-- Paso 3: Actualizar código aplicación para usar deleted_at

-- Paso 4: (tras validación) Eliminar columnas antiguas
ALTER TABLE nb_habitaciones
  DROP COLUMN eliminada,
  DROP COLUMN activa,   -- Si la lógica lo permite
  DROP COLUMN visible;  -- Si la lógica lo permite
```

**Caso especial: nb_habitaciones (triple soft delete)**

Posible lógica de negocio:
- `eliminada='si'` → `deleted_at = NOW()`
- `activa='no'` → nueva columna `is_active BOOLEAN DEFAULT TRUE`
- `visible='no'` → nueva columna `is_visible BOOLEAN DEFAULT TRUE`

**Costo estimado:** 20-30 horas de desarrollo + testing
**Beneficio:** Código más mantenible, queries más claras, auditoría mejorada

---

**4. AÑADIR ÍNDICES FALTANTES**

**Impacto:** MEDIO-ALTO
**Esfuerzo:** BAJO
**Riesgo:** BAJO

**Índices recomendados:**

```sql
-- 1. nb_reservas: queries de reporting por país/moneda
CREATE INDEX idx_pais_moneda_estado ON nb_reservas(pais, moneda, estado);

-- 2. nb_habitaciones: lookup por id_global (sincronización canales)
CREATE UNIQUE INDEX idx_id_global ON nb_habitaciones(id_global);

-- 3. nb_cupos: queries de disponibilidad (si no existe)
-- Validar primero: SHOW CREATE TABLE nb_cupos;
CREATE INDEX idx_habitacion_fecha ON nb_cupos(id_habitacion, fecha);
CREATE INDEX idx_hotel_fecha ON nb_cupos(id_hotel, fecha);

-- 4. nb_reservas_habitaciones: queries por fecha de entrada/salida
CREATE INDEX idx_fecha_entrada ON nb_reservas_habitaciones(fecha_entrada);
CREATE INDEX idx_fecha_salida ON nb_reservas_habitaciones(fecha_salida);

-- 5. nb_notas: lookup por tipo de entidad
CREATE INDEX idx_tipo_identificador ON nb_notas(tipo, identificador);

-- 6. nb_acciones: queries de auditoría por tipo y fecha
CREATE INDEX idx_tipo_timestamp ON nb_acciones(tipo, timestamp);

-- 7. nb_mod_channels_bookings: lookup por canal
CREATE INDEX idx_canal_portal ON nb_mod_channels_bookings(canal, portal);
```

**Validación de impacto:**
```sql
-- Antes de crear índice, estimar impacto con EXPLAIN
EXPLAIN SELECT * FROM nb_reservas
WHERE pais = 'ES' AND moneda = 'EUR' AND estado = 'confirmada';

-- Verificar si usa índice propuesto
-- rows escaneadas: 6.9M (full scan) → 50K (con índice) = 99% reducción
```

**Costo estimado:** 4-8 horas
**Beneficio:** 50-90% mejora en queries específicas

---

### ALTAS (Implementar en 3-6 meses)

**5. MIGRAR PASSWORDS DE MD5 A BCRYPT**

**Impacto:** CRÍTICO DE SEGURIDAD
**Esfuerzo:** MEDIO
**Riesgo:** BAJO (si se hace progresivo)

**Problema:**
```sql
nb_usuarios.pass VARCHAR(32)  -- MD5 hash (inseguro desde 2004)
```

**Solución:**
```sql
-- Ampliar columna para bcrypt (60 caracteres)
ALTER TABLE nb_usuarios MODIFY pass VARCHAR(255) NOT NULL;

-- Agregar columna temporal de migración
ALTER TABLE nb_usuarios ADD COLUMN pass_migrated BOOLEAN DEFAULT FALSE;
```

**Estrategia de migración progresiva:**
1. Al login exitoso con MD5 → re-hashear con bcrypt, marcar `pass_migrated=TRUE`
2. Forzar reset de password para usuarios que no logean en 6 meses
3. Tras 12 meses, deshabilitar login con MD5

**Código de migración (pseudocódigo):**
```php
// En función de login
if (!user.pass_migrated) {
    // Validar con MD5 (legacy)
    if (md5(input_password) === user.pass) {
        // Re-hashear con bcrypt
        user.pass = bcrypt(input_password);
        user.pass_migrated = true;
        user.save();
        // Continuar login
    }
} else {
    // Validar con bcrypt (moderno)
    if (bcrypt_verify(input_password, user.pass)) {
        // Login exitoso
    }
}
```

---

**6. AÑADIR COLUMNA `created_at` EN TABLAS PRINCIPALES**

**Impacto:** MEDIO
**Esfuerzo:** BAJO
**Riesgo:** BAJO

**Problema:** Mayoría de tablas solo tienen `last_update`, no fecha de creación explícita.

**Solución:**
```sql
-- Agregar created_at en tablas críticas
ALTER TABLE nb_habitaciones
  ADD COLUMN created_at TIMESTAMP NULL DEFAULT NULL,
  ADD INDEX idx_created_at (created_at);

-- Rellenar con aproximación (usar last_update o timestamp más antiguo)
UPDATE nb_habitaciones
SET created_at = last_update;

-- Para nuevas inserciones, configurar DEFAULT CURRENT_TIMESTAMP
ALTER TABLE nb_habitaciones
  MODIFY created_at TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;
```

**Tablas prioritarias:**
- nb_habitaciones, nb_hoteles, nb_ofertas, nb_paquetes, nb_suplementos, nb_politicas

---

**7. NORMALIZAR TABLAS `.lang` (Renombrar a `_lang`)**

**Impacto:** BAJO
**Esfuerzo:** MEDIO
**Riesgo:** MEDIO (requiere cambios en código)

**Problema:** Nombre de tabla con punto: `nb_hoteles.lang`

**Solución:**
```sql
RENAME TABLE `nb_hoteles.lang` TO nb_hoteles_lang;
RENAME TABLE `nb_habitaciones.lang` TO nb_habitaciones_lang;
-- ... (27 tablas en total)
```

**Ventajas:**
- Compatibilidad con ORMs (Eloquent, Doctrine, ActiveRecord)
- Evita confusión con notación de base.tabla
- Estándar de naming consistente

**Costo:** 10-15 horas (incluye actualización de código)

---

### MEDIAS (Implementar en 6-12 meses)

**8. IMPLEMENTAR PARTICIONAMIENTO EN nb_reservas_desgloses**

**Tabla:** `nb_reservas_desgloses` (5.3M filas, 22 GB - tabla más grande)

**Estrategia:** RANGE partitioning por año (basado en fecha de reserva)

```sql
ALTER TABLE nb_reservas_desgloses
PARTITION BY RANGE (YEAR(fecha)) (
  PARTITION p2020 VALUES LESS THAN (2021),
  PARTITION p2021 VALUES LESS THAN (2022),
  PARTITION p2022 VALUES LESS THAN (2023),
  PARTITION p2023 VALUES LESS THAN (2024),
  PARTITION p2024 VALUES LESS THAN (2025),
  PARTITION p2025 VALUES LESS THAN (2026),
  PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Beneficio:**
- Queries filtradas por año solo escanean partición relevante (90%+ reducción)
- Mantenimiento (archivado) más simple: `DROP PARTITION p2020` en lugar de DELETE masivo
- Backups incrementales por partición

**Prerrequisito:** Validar que columna `fecha` exista y sea parte de todas las queries

---

**9. CONSIDERAR MIGRACIÓN DE nb_cupos A TABLA TEMPORAL**

**Problema:** `nb_cupos` tiene datos históricos innecesarios (disponibilidad de fechas pasadas)

**Solución:**
```sql
-- Crear tabla histórica
CREATE TABLE nb_cupos_historico LIKE nb_cupos;

-- Mover datos antiguos (fecha < hace 6 meses)
INSERT INTO nb_cupos_historico
SELECT * FROM nb_cupos WHERE fecha < DATE_SUB(NOW(), INTERVAL 6 MONTH);

DELETE FROM nb_cupos WHERE fecha < DATE_SUB(NOW(), INTERVAL 6 MONTH);

-- Job mensual de archivado
```

**Beneficio:**
- Reducción de 50-70% del tamaño de nb_cupos
- Queries más rápidas (menos filas)
- Datos históricos disponibles para reporting

---

**10. EVALUAR SHARDING HORIZONTAL DE nb_mod_channels_inventory**

**Tabla:** `nb_mod_channels_inventory` (13.7M filas, 6.25 GB)

**Escenario:** Si volumen crece 10x (137M filas, 62 GB)

**Estrategia:** Shard por `id_hotel` (cada shard gestiona N hoteles)

**Decisión:** Postponer hasta que tamaño sea insostenible (>100GB) o latencia sea crítica (p95 >500ms)

---

## CONCLUSIONES FINALES

### Resumen de Hallazgos

**Fortalezas del diseño actual:**
1. Denormalización estratégica bien ejecutada (nb_precios_habitacion_combinacion)
2. Sistema de auditoría con `last_update` en 95% de tablas
3. Índices compuestos inteligentes en tablas críticas de channels
4. Patrón i18n funcional (aunque mejorable)
5. Motor InnoDB 100% (transacciones ACID)

**Debilidades críticas:**
1. **AUSENCIA TOTAL DE FOREIGN KEYS** (mayor riesgo de integridad)
2. **PRIMARY KEY VARCHAR en nb_reservas** (penalización de 30-40% en JOINs)
3. **PASSWORDS MD5** (vulnerabilidad crítica de seguridad)
4. **Soft deletes inconsistentes** (3 patrones diferentes)
5. **Falta columna `created_at`** en mayoría de tablas

**Escala actual:**
- 155M filas totales
- 71.57 GB (58.52 GB datos + 13.05 GB índices)
- Ratio índices/datos: 22% (saludable)
- Motor: InnoDB 100% (correcto para transaccional)

**Proyección de escala (10x en 3 años):**
- 1.55B filas
- 715 GB total
- **Tablas problemáticas:**
  - `nb_reservas_desgloses`: 220 GB (requiere particionamiento)
  - `nb_mod_channels_inventory`: 62 GB (considerar sharding)
  - `nb_precios_habitacion_combinacion`: 15 GB (monitorear)

**Recomendación estratégica:**

**Prioridad 1 (0-3 meses):**
- Implementar Foreign Keys en tablas críticas (integridad)
- Añadir índices faltantes (performance rápida)
- Migrar passwords MD5 a bcrypt (seguridad crítica)

**Prioridad 2 (3-6 meses):**
- Estandarizar soft deletes a `deleted_at`
- Agregar `created_at` en tablas principales
- Renombrar tablas `.lang` a `_lang`

**Prioridad 3 (6-12 meses):**
- Evaluar migración de `nb_reservas.identificador` a BIGINT
- Implementar particionamiento en nb_reservas_desgloses
- Archivado automático de nb_cupos históricos

**Costo total estimado (Prioridad 1):** 80-120 horas de desarrollo + testing
**Beneficio esperado:** 30-50% mejora en queries críticas, eliminación de clase completa de bugs, seguridad mejorada

---

## APÉNDICE: ESTRUCTURA DE TABLAS CORE

### nb_reservas (COMPLETA)

```sql
CREATE TABLE nb_reservas (
  identificador VARCHAR(13) NOT NULL PRIMARY KEY,
  timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  titulo VARCHAR(10) NOT NULL,
  nombre VARCHAR(50) NOT NULL,
  apellidos VARCHAR(100) NOT NULL,
  direccion VARCHAR(100) NOT NULL,
  codigo_postal VARCHAR(10) NOT NULL,
  ciudad VARCHAR(255) NULL,
  provincia VARCHAR(10) NULL,
  pais CHAR(2) NOT NULL,
  telefono VARCHAR(30) NOT NULL,
  fax VARCHAR(30) NOT NULL,
  movil VARCHAR(30) NOT NULL,
  email VARCHAR(50) NOT NULL,
  pasaporte VARCHAR(15) NULL,
  peticiones MEDIUMTEXT NOT NULL,
  dob DATE NULL,
  info_cliente TEXT NULL,
  info_hotel TEXT NULL,
  llegada VARCHAR(150) NOT NULL,
  precio_total DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  primer_pago DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  segundo_pago DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  metodo_pago ENUM('tpv','tarjeta','transferencia','efectivo','credito','giro_postal','paypal','otb','financiado','otro') NOT NULL DEFAULT 'otro',
  tipo_pago ENUM('completo','noche','porcentaje','ninguno') NOT NULL DEFAULT 'ninguno',
  pre_reserva TINYINT NOT NULL DEFAULT 0,
  upgrade TINYINT NOT NULL DEFAULT 0,
  gastos_emision DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  autorizacion ENUM('si','no') NULL,
  promocion VARCHAR(10) NOT NULL,
  origen VARCHAR(255) NOT NULL,
  origen_ads VARCHAR(255) NULL,
  callcenter VARCHAR(255) NOT NULL,
  medio VARCHAR(255) NULL,
  datos JSON NULL,
  disfrute_productos JSON NULL,
  estado ENUM('confirmada','cancelada','nula') NOT NULL DEFAULT 'confirmada',
  revisada ENUM('si','no') NOT NULL DEFAULT 'no',
  no_show TINYINT NOT NULL DEFAULT 0,
  fecha_cobro DATETIME NULL,
  idioma CHAR(2) NOT NULL,
  moneda CHAR(3) NOT NULL DEFAULT 'EUR',
  last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX estado (estado, email),
  INDEX id_hotel_r (gastos_emision, last_update),
  INDEX last_update (last_update, timestamp),
  INDEX timestamp (timestamp)
) ENGINE=InnoDB DEFAULT CHARSET=utf8_general_ci;
```

### nb_habitaciones (COMPLETA)

Ver sección "3. HABITACIONES" para estructura completa.

### nb_hoteles (COMPLETA)

Ver sección "2. HOTELES" para estructura completa.

---

**FIN DEL DOCUMENTO DE INGENIERÍA INVERSA**

---

**Siguiente paso recomendado:**
Generar diagrama E-R en notación Chen con herramienta especializada (dbdiagram.io, draw.io, Lucidchart) usando las relaciones implícitas documentadas en este análisis.
